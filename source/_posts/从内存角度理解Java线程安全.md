title: 从内存角度理解 Java 线程安全
tags: |-

- 内存
- Java
- 线程安全
- Thread-save
- java
  permalink: thread-safe-jmm
  id: 14
  updated: '2014-09-23 14:54:34'
  date: 2014-09-01 17:20:34

---

线程安全：无非就是保证多个线程有序的访问或修改共享数据。

JVM 定义了自己的内存模型，对开发者屏蔽了平台操作内存的细节。在 Java 中，线程之间是无法直接通信的，只能通过共享对象才能相互通信。下面这张图就诠释了 Java 中线程是如何通信的。

![](http://geeekr.qiniudn.com/images/2/c4/52d147bf0d09b14b770d3990740cb.png)

上图包含了连个概念：可见性，有序性。

## 可见性

线程 A 从主内存中拷贝变量 x 的副本到本地内存中，然后在本地内存中修改 x 的值，jvm 控制将 x 的值同步到主内存中。线程 B 也是如此。两个线程就是这样通过主内存共享对象实现两者的通信的。

但是如果他们的执行顺序出了差错，那么 x 的值就会出错。

例如：

1. 线程 A 拷贝 x 副本到本地内存。
2. 线程 A 对 x 的值+1，x 的值为 11。
3. 线程 B 拷贝 x 副本到本地内存。
4. 线程 B 对 x 的值-1，x 的值为 9。
5. 线程 A 同步到主内存，主内存的 x=11。
6. 线程 B 同步到主内存，主内存的 X=9。

## 有序性

所以要保证同一时刻只有一个线程能操作数据。

Java 引入了 synchronized 关键字将一段代码互斥，保证了线程访问数据的顺序。

```
synchronized(lock){
	some code...
}
```

如果 synchronized 关键字与 static 关键字同时用则锁对象为 class 对象，否则所对象为实例对象。
